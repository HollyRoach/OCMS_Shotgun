"""
================================
Align and remove host sequences
================================


Overview
========

This pipeline is based on CGATMetaSequencing pipeline_filter

1) Checks input files 
2) Map host reads with HISAT2
3) Filter reads from bam files


Configuration
=============
The pipeline requires a configured :file:`pipeline.yml` file.

Default configuration files can be generated by executing:
    
    ocms_shotgun remove_host config

Dependencies
============

HISAT2
SAMtools
BEDtools

source /well/kir/config/modules.sh
module load HISAT2/2.2.1-gompi-2022b
module load BEDTools/2.30.0-GCC-12.2.0
module load SAMtools/1.17-GCC-12.2.0

Code
====

"""

from ruffus import *
from cgatcore import pipeline as P
from cgatcore import iotools as IOTools

import os,sys,re

import ocmsshotgun.modules.Utility as utility
import ocmsshotgun.modules.PreProcess as pp

# set up params
PARAMS = P.get_parameters(["pipeline.yml"])

# check that input files correspond
indir = PARAMS.get('general_input', 'input.dir')
FASTQ1S = utility.check_input(indir)

# forcing input.dir as input source because of filterMapping add_input.
# looking for a more flexible way of interacting with add_input
assert indir == 'input.dir', (
    "Input files need to be in input.dir."
)
################################################################################
# remove host sequences with bmtagger
################################################################################
@active_if(PARAMS['general_tool'] == 'bmtagger')
@follows(mkdir('bmtagger.dir'))
@transform(FASTQ1S,
           regex('.+/(.+)_rRNAremoved.fastq.1.gz'),
           r'bmtagger.dir/\1_dehost.fastq.1.gz')
def runBmtagger(fastq1, outfile):
    '''Remove host contamination using bmtagger'''

    tool = pp.bmtagger(fastq1, outfile, **PARAMS)
    statements, tmpfiles = tool.buildStatement()

    # one statement for each host genome specified
    for statement in statements:
        P.run(statement, 
              job_threads=PARAMS['bmtagger_job_threads'], 
              job_memory=PARAMS['bmtagger_job_memory'],
              job_options=PARAMS.get('bmtagger_job_options',''))
    
    statement, to_unlink  = tool.postProcess(tmpfiles)
    P.run(statement)
    for f in to_unlink:
        os.unlink(f)

################################################################################
#align reads to chosen reference genome using hisat2
#converts the output from sam to bam
################################################################################
@active_if(PARAMS['general_tool'] == 'hisat')
@mkdir("hisat.dir")
@transform(FASTQ1S,
           regex(r'.+/(\S+).fastq.1.gz$'),
           r"hisat.dir/\1_dehost.mapped.bam")
def mapHisat2(infile,outfile):

    tool = pp.hisat2(infile, outfile, **PARAMS)
    statement = tool.buildStatement()
    P.run(statement,
          job_threads = PARAMS["hisat2_job_threads"],
          job_memory = PARAMS["hisat2_job_memory"])

    statement = tool.postProcess()
    P.run(statement,
          job_threads = PARAMS["hisat2_job_threads"],
          job_memory = PARAMS["hisat2_job_memory"])

################################################################################    
#filter the reads from the mapping output and convert to fasta/q file(s)
################################################################################
@active_if(PARAMS['general_tool'] == 'hisat')
@follows(mapHisat2)
@transform(mapHisat2,
           regex(r"hisat.dir/(\S+)_dehost.mapped.bam"),
           # fastq file associated with bam file
           add_inputs(r"input.dir/\1.fastq.1.gz"), 
           r"hisat.dir/\1_dehost.fastq.1.gz")
def filterMapping(infiles,outfile):

    bam = infiles[0]
    fq1 = infiles[1]
    # get fastq data corresponding with bam file
    seqobj = utility.matchReference(fq1, outfile, **PARAMS)
    tool = pp.filterFromBam(bam, outfile, seqobj,
                            **{'inf_suffix':'.mapped.bam'}, **PARAMS)

    statement = tool.buildStatement()
    P.run(statement,
          job_threads = PARAMS['bamfilter_job_threads'],
          job_memory = PARAMS['bamfilter_job_memory'])
    
    statement = tool.postProcess() # remove bam files?
    #P.run(statement)

@follows(filterMapping)
def full():
    pass

def main(argv=None):
    if argv is None:
        argv = sys.argv
    P.main(argv)


if __name__ == "__main__":
    sys.exit(P.main(sys.argv))    